CREATE OR REPLACE QUERY circleDetection (vertex<User> srcId)  FOR GRAPH AntiFraud{
/*
  This is an anti-money laundering query. It detects money flow circle from a starting user. 
 
  Start from a user, find all the transaction paths originated from the input user 
  and eventually come back to the user. The path length is limited from 3 to 6. 

  Sample input
  User: any integer between 1 and 500.
*/
  Typedef tuple<EDGE e, VERTEX v, double amount, int ts> EdgeTuple;
  MinAccum<int> @minLeftDist = GSQL_INT_MAX;
  MinAccum<int> @minRightDist = GSQL_INT_MAX;
  MinAccum<int> @@minSrcSendTime = GSQL_INT_MAX;
  MaxAccum<int> @@maxSrcReceiveTime = 0;

  OrAccum @isValid = false;//flag used to record valid vertices in the subgraph

  int stepLowLimit = 3;
  int stepHighLimit = 6;

  int halfStep;
  int step;
  //The following are used for aggregation on src
  SumAccum<int> @validTransNum = 0;
  SumAccum<int> @validTransSum = 0;
  MaxAccum<int> @maxRank = 0;
  ListAccum<ListAccum<EdgeTuple>> @edgeTupleList;
  ListAccum<ListAccum<EdgeTuple>> @newEdgeTupleList;
  ListAccum<ListAccum<EdgeTuple>> @@circleEdgeTuples;
  OrAccum @receiveNewPath = false;

  //The following is used for printing edges and vertices
  SetAccum<vertex> @@vSet;
  ListAccum<ListAccum<Edge>> @@circlePaths;
  
  //starting from input User vertex
  Seed = {srcId};

  //oneStep to find out the src's minSendTime and maxReceiveTime, initialize the distance info for srcId
  Seed = SELECT src
      FROM Seed:src - ((User_Transfer_Transaction|User_Recieve_Transaction):e) -> Transaction:tgt
      ACCUM
        CASE WHEN e.type == "User_Transfer_Transaction" 
             THEN @@minSrcSendTime += tgt.ts
        ELSE
          @@maxSrcReceiveTime += tgt.ts
        END
      Post-ACCUM
        src.@minLeftDist = 0,
        src.@minRightDist = 0,
        src.@isValid = true
      //make sure that it has a loop, if @@maxSrcRecievTime < @@minSrcSendTime, then there is no loop 
      //Because, if @@maxSrcRecievTime < @@minSrcSendTime, all the valid money it receives are before it sends out money
      HAVING @@maxSrcReceiveTime >= @@minSrcSendTime
      ;

  //PRINT epoch_to_datetime(@@maxSrcReceiveTime), epoch_to_datetime(@@minSrcSendTime), startTime, endTime;
  #Now start the bidirectional search of loops for srcId
  # 1) First bidirecitonal search for the potential subgraph for all loops of srcId
  # 2) Then one directional search to valid each path inside the subgraph using path filters, i.e. time increase along the path

  //set X as Seed
  X (_) = Seed;//X is used to do positive direction traversal
  Y (_) = Seed;//Y is used to do negative direction traversal

  # In order to do bidirectional search, we separate search into two steps,
  # i) search for half of totoal steps, only touch unmark vertices, 
  #  i.e. positive directional search only touch positive unmarked vertices,
  #       negative search only touch negative unmarked vertices
  # ii) After the first half search, the following search only happens for marked vertices,
  #  i.e. positive directional search only touch negative marked and positive unmarked vertices
  #       negative search only touch negative positive marked and negative unmarked vertices
  # if one of touched vertex fulfil the condition that positive distance + negative distance < stepHighLimit, it is a valid vertex
  //First search for half of total steps
  halfStep = (stepHighLimit + 1)/2;
  step = 0;
  WHILE step <= halfStep AND X.size() + Y.size() > 0
  DO
    IF X.size() > 0
    THEN
      //from User to Transaction
      X = SELECT tgt
        FROM X:src - (User_Transfer_Transaction:e) -> Transaction:tgt
        WHERE 
          //tgt ts must be bigger than minSrcSendTime
          //so that all paths has increasing time
          tgt.ts >= @@minSrcSendTime 
          AND src.@minLeftDist < GSQL_INT_MAX 
          AND tgt.@minLeftDist == GSQL_INT_MAX
        ACCUM 
          tgt.@minLeftDist += src.@minLeftDist + 1               
        POST-ACCUM
          CASE WHEN tgt.@minLeftDist < GSQL_INT_MAX and tgt.@minRightDist < GSQL_INT_MAX
                 AND tgt.@minLeftDist + tgt.@minRightDist <= 2 * stepHighLimit
               THEN
                 tgt.@isValid = true
          END
        ;
       //from Transaction to User
      X = SELECT tgt
        FROM X:src - (User_Recieve_Transaction_Rev:e) -> User:tgt
        WHERE src.@minLeftDist < GSQL_INT_MAX 
          //only when tgt is not left visited, update the distance info
          AND tgt.@minLeftDist == GSQL_INT_MAX
        ACCUM
          tgt.@minLeftDist += src.@minLeftDist + 1               
        POST-ACCUM
          CASE WHEN tgt.@minLeftDist < GSQL_INT_MAX and tgt.@minRightDist < GSQL_INT_MAX
                    AND tgt.@minLeftDist + tgt.@minRightDist <= 2 * stepHighLimit
               THEN
                 tgt.@isValid = true
          END
        HAVING tgt != srcId
      ;
    END;

    IF Y.size() > 0
    THEN
      Y = SELECT tgt
        FROM Y:src - (User_Recieve_Transaction:e) -> Transaction:tgt
        WHERE
          tgt.ts <= @@maxSrcReceiveTime 
          AND src.@minRightDist < GSQL_INT_MAX 
          AND tgt.@minRightDist == GSQL_INT_MAX
        ACCUM
          tgt.@minRightDist += src.@minRightDist + 1
        POST-ACCUM
          CASE WHEN tgt.@minLeftDist < GSQL_INT_MAX
                 AND tgt.@minRightDist < GSQL_INT_MAX
                 AND tgt.@minLeftDist + tgt.@minRightDist <= 2 * stepHighLimit
               THEN
                 tgt.@isValid = true
          END
        ;
      //from Transaction to User
      Y = SELECT tgt
         FROM Y:src - (User_Transfer_Transaction_Rev:e) -> User:tgt
         WHERE src.@minRightDist < GSQL_INT_MAX 
           //only when tgt is not left visited, update the distance info
           AND tgt.@minRightDist == GSQL_INT_MAX
         ACCUM
           tgt.@minRightDist += src.@minRightDist + 1               
         POST-ACCUM
           CASE WHEN tgt.@minLeftDist < GSQL_INT_MAX and tgt.@minRightDist < GSQL_INT_MAX
                     AND tgt.@minLeftDist + tgt.@minRightDist <= 2 * stepHighLimit
                THEN
                  tgt.@isValid = true
           END
         HAVING tgt != srcId
      ;
    END;
    step = step + 1;
  END;
  # start the last half of search, only touch marked vertices
  WHILE step <= stepHighLimit AND X.size() + Y.size() > 0
  DO
    IF X.size() > 0
    THEN
      //from User to Transaction
      X = SELECT tgt
        FROM X:src - (User_Transfer_Transaction:e) -> Transaction:tgt
        WHERE tgt.@minRightDist < GSQL_INT_MAX//tgt must be touched in the above the negative search
          AND tgt.ts >= @@minSrcSendTime 
          AND src.@minLeftDist < GSQL_INT_MAX 
          AND tgt.@minLeftDist == GSQL_INT_MAX
        ACCUM 
          tgt.@minLeftDist += src.@minLeftDist + 1               
        POST-ACCUM
          CASE WHEN tgt.@minLeftDist < GSQL_INT_MAX and tgt.@minRightDist < GSQL_INT_MAX
                 AND tgt.@minLeftDist + tgt.@minRightDist <= 2 * stepHighLimit
               THEN
                 tgt.@isValid = true
          END
        ;
       //from Transaction to User
      X = SELECT tgt
        FROM X:src - (User_Recieve_Transaction_Rev:e) -> User:tgt
        WHERE tgt.@minRightDist < GSQL_INT_MAX//tgt must be touched in the above the negative search
          AND src.@minLeftDist < GSQL_INT_MAX 
          //only when tgt is not left visited, update the distance info
          AND tgt.@minLeftDist == GSQL_INT_MAX
        ACCUM
          tgt.@minLeftDist += src.@minLeftDist + 1               
        POST-ACCUM
          CASE WHEN tgt.@minLeftDist < GSQL_INT_MAX and tgt.@minRightDist < GSQL_INT_MAX
                    AND tgt.@minLeftDist + tgt.@minRightDist <= 2 * stepHighLimit
               THEN
                 tgt.@isValid = true
          END
        HAVING tgt != srcId
      ;
    END;

    IF Y.size() > 0
    THEN
      Y = SELECT tgt
        FROM Y:src - (User_Recieve_Transaction:e) -> Transaction:tgt
        WHERE tgt.@minLeftDist < GSQL_INT_MAX//tgt must be touched in the above positive search
          AND tgt.ts <= @@maxSrcReceiveTime 
          AND src.@minRightDist < GSQL_INT_MAX
          AND tgt.@minRightDist == GSQL_INT_MAX
        ACCUM
          tgt.@minRightDist += src.@minRightDist + 1
        POST-ACCUM
          CASE WHEN tgt.@minLeftDist < GSQL_INT_MAX
                 AND tgt.@minRightDist < GSQL_INT_MAX
                 AND tgt.@minLeftDist + tgt.@minRightDist <= 2 * stepHighLimit
               THEN
                 tgt.@isValid = true
          END
        ;
      //from Transaction to User
      Y = SELECT tgt
        FROM Y:src - (User_Transfer_Transaction_Rev:e) -> User:tgt
        WHERE tgt.@minLeftDist < GSQL_INT_MAX//tgt must be touched in the above positive search
          AND src.@minRightDist < GSQL_INT_MAX 
          //only when tgt is not left visited, update the distance info
          AND tgt.@minRightDist == GSQL_INT_MAX
        ACCUM
          tgt.@minRightDist += src.@minRightDist + 1               
        POST-ACCUM
          CASE WHEN tgt.@minLeftDist < GSQL_INT_MAX and tgt.@minRightDist < GSQL_INT_MAX
                    AND tgt.@minLeftDist + tgt.@minRightDist <= 2 * stepHighLimit
               THEN
                 tgt.@isValid = true
          END
        HAVING tgt != srcId
        ;
    END;
    step = step + 1;
  END;

  #start valid path traversal and circle detection
  step = 0;
  //reset X as Seed
  X = Seed;
  WHILE step <= stepHighLimit
  DO
    //from User to Transaction
    X = SELECT tgt
      FROM X:src - (User_Transfer_Transaction:e) -> Transaction:tgt
      WHERE tgt.@isValid == true
      ACCUM
        int ts = tgt.ts,
        CASE
          //if X is Seed, then only send edge over
          WHEN src.@edgeTupleList.size() == 0
            THEN tgt.@newEdgeTupleList += [EdgeTuple(e, src, tgt.amount, ts)]
          ELSE
            FOREACH path in src.@edgeTupleList
            DO
              tgt.@newEdgeTupleList += path + [EdgeTuple(e, src, tgt.amount, ts)]
            END
        END,
        //reset receiveNewPath as false
        tgt.@receiveNewPath = false
      POST-ACCUM
        CASE 
          WHEN tgt.@newEdgeTupleList.size() > 0
          THEN 
            tgt.@edgeTupleList = tgt.@newEdgeTupleList,
            tgt.@receiveNewPath = true,
            tgt.@newEdgeTupleList.clear()
        END
      HAVING tgt.@receiveNewPath == true
    ;

    //from Transaction to User
    X = SELECT tgt
      FROM X:src - (User_Recieve_Transaction_Rev:e) -> User:tgt
      WHERE tgt.@isValid == true
      ACCUM
        FOREACH path in src.@edgeTupleList
        DO
          CASE WHEN tgt == srcId OR (NOT PathContainsV(path, tgt))
               THEN
                 tgt.@newEdgeTupleList += path + [EdgeTuple(e, src, src.amount, src.ts)]
          END
        END,
        //reset receiveNewPath as false
        tgt.@receiveNewPath = false
      POST-ACCUM
        CASE 
          WHEN tgt.@newEdgeTupleList.size() > 0
          THEN
            CASE
              //if it backs to start point, there is a valid circle
              WHEN tgt == srcId
                THEN
                  //step + 1 gives the current updated step
                  //it is the number of User -> User steps for current paths (there maybe multiple paths but all of them should have the same length)
                  CASE WHEN step + 1 >= stepLowLimit
                       THEN @@circleEdgeTuples += tgt.@newEdgeTupleList
                  END
              //else, overwrite the old @edgeTupleList, since the old one is already used
              ELSE tgt.@edgeTupleList = tgt.@newEdgeTupleList
            END,
            tgt.@receiveNewPath = true,
            tgt.@newEdgeTupleList.clear()
        END
      HAVING tgt.@receiveNewPath == true and tgt != srcId
    ;

    step = step + 1;
  END;
  //printJSON only if it is directly called or else return @@circleEdgeTuples directly
  //use the drainRatio to filter out invalid paths
  //store all valid vertices into @@vSet and all paths into @@circlePaths
  PRINT @@circleEdgeTuples;
}